2021年7月15日11:02:18
    构造函数初始化列表（顾名思义，只出现在构造函数的定义里）是出现在函数参数表和冒号后，
    但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造
    函数的任何代码执行之前。**这是初始化所有Const的地方！**

2021年7月22日10:05:08
    使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每
    一处重复赋值代码，这样将是代码膨胀，在速度方面获得的好处就会减少。
    (已实验过了.简单的实验调用内联函数和调用在类外实现的函数（两者实现一样）,但内联更快)

    内联函数的最重要的使用之一是用做访问函数（access funtion).

2021年7月23日14:18:40
    全局对象会在Main调用之前就会调用构造函数,静态对象是等到被调用的时候才调用构造函数。
    而在Main结束后,静态对象的析构函数会按创建时相反的顺序被调用，全局对象的析构在最后才调用。
    
2021年7月26日14:25:47
    Malloc和free是C语言的标准库函数。
    使用Malloc必须决定对象的长度。分配了一块内存而不是生了一个对象。所以它返回一个vodi * 类型指针。而C++不允许将一个void*类型指针赋予任何其他指针。所以必须做类型转换。

    C    : Obj *obj = (obj *)malloc(sizeof(Obj));
    C++  : Obj *obj = new Obj;

    而New和Delete是C++的运算符。C++的解决方案是把创建一个对象所需的所有动作都结合再一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。

    C++使在堆里创建对象的过程变得简单了——只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。

    使用 void* 类型指针进行delete操作，可能会成为一个程序错误，除非指针所值的内容是非常的简单的。因为，它将不执行析构函数(没有确切的类型)

2021年7月28日15:36:52
    构造函数的初始化表达式允许我们显式地调用成员对象的构造函数。事实上，也没有其他办法可以调用那些构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有的其他的构造函数。

    Y():X(),T(){}  //先调用X的构造函数，再调用T，最后才调用Y;

     伪构造函数语法：方便且具有良好的编码风格（作者）
        int i(100)  ==  ( int i =100 );






还没未看的文章:
    13.2.2 对指针的清楚责任（书中说后面的章节中有更加智能的方法）
    13.5 重载New和Delete之后都没看（包括这章）
