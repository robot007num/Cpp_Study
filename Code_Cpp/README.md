2021年7月15日11:02:18

    构造函数初始化列表（顾名思义，只出现在构造函数的定义里）是出现在函数参数表和冒号后，
    但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造
    函数的任何代码执行之前。**这是初始化所有Const的地方！**

2021年7月22日10:05:08

    使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每
    一处重复赋值代码，这样将是代码膨胀，在速度方面获得的好处就会减少。
    (已实验过了.简单的实验调用内联函数和调用在类外实现的函数（两者实现一样）,但内联更快)

    内联函数的最重要的使用之一是用做访问函数（access funtion).

2021年7月23日14:18:40

    全局对象会在Main调用之前就会调用构造函数,静态对象是等到被调用的时候才调用构造函数。
    而在Main结束后,静态对象的析构函数会按创建时相反的顺序被调用，全局对象的析构在最后才调用。
    
2021年7月26日14:25:47

    Malloc和free是C语言的标准库函数。
    使用Malloc必须决定对象的长度。分配了一块内存而不是生了一个对象。所以它返回一个vodi * 类型指针。而C++不允许将一个void*类型指针赋予任何其他指针。所以必须做类型转换。

    C    : Obj *obj = (obj *)malloc(sizeof(Obj));
    C++  : Obj *obj = new Obj;

    而New和Delete是C++的运算符。C++的解决方案是把创建一个对象所需的所有动作都结合再一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。

    C++使在堆里创建对象的过程变得简单了——只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。

    使用 void* 类型指针进行delete操作，可能会成为一个程序错误，除非指针所值的内容是非常的简单的。因为，它将不执行析构函数(没有确切的类型)

2021年7月28日15:36:52

    构造函数的初始化表达式允许我们显式地调用成员对象的构造函数。事实上，也没有其他办法可以调用那些构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有的其他的构造函数。

    Y():X(),T(){}  //先调用X的构造函数，再调用T，最后才调用Y;

     伪构造函数语法：方便且具有良好的编码风格（作者）
        int i(100)  ==  ( int i =100 );

2021年7月29日10:34:50

     只有通过继承,才能重新定义它的函数。而对于成员对象，只能操作这个对象的公共接口,而不能重定义它.

构造函数和析构函数调用的次序:

      构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函函数。调用析构函数则严格按照构造函数相反的次序。
      另一个有趣对象是，对于成员函数，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中的声明的次序所决定的。
      代码：CPP_SIGNLE/chapter-14:Order.cpp

关于继承和组合的选择:

       组合通常是在希望新类内部具有已存在的类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。
       右存在的类创建一个新类，并且希望这个新类与已存在的类有着严格相同的接口（希望增加任何我们想要加入的其他成员函数），所以能在已经用过这个已存在类的任何地方使用这个新类。这就是可以使用继承的地方。
       代码：CPP_SIGNLE/chapter-14:FName1.cpp FName2.cpp 

私有继承注意的点：

        类默认是private继承;
        私有继承是创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能。

        Tips:
        当私有继承时，基类的所有public成员都变成private。如果希望它们的任何一个是可视的,只要用派生类的public部分声明它们的名字即可。

        代码：CPP_SIGNLE/PrivateInheritance.cpp

2021年7月29日17:15:47： 

        已看完第14章

2021年7月30日15:14:34：

向上类型转换（仅处理地址）：
        取一个对象的地址(指针或引用)，并将其作为基类的地址来处理。
        代码：CPP_SIGNLE/chapter-15/Instrument2.cpp

/*
运行程序Instrument2.cpp可以看到这个程序中的问题。调用输出的是基类的函数。显然，这不是所希望的输出，因此我们知道这个对象实际上是Wind而不是一个Instrument。应当调用的是Wind::play。为此，由Instrument派生的任何对象不论它处于什么位置都应当使用它的play()版本。
然而，当对函数用C方法时，Instrument2.cpp的行为并不使用惊奇。为了理解这个问题，需要知道捆绑（binding）的概念。

        引入这段话是为了理解为什么要用虚函数。如果不用虚函数的话，会产生什么效果。
        以前只知道虚函数可以重写函数（作用），却不知道怎样准确的使用它和未使用产生的效果。
*/

把函数体和函数调用相联系为捆绑。
早捆绑：捆绑在程序运行之前（由编译器和连接器）完成时。
晚捆绑：捆绑根据对象的类型，发生在运行时。


虚函数：

        作用：当一个语言实现晚捆绑时，必须有某种机制（虚函数）来确定运行时对象的类型并调用合适的成员函数。

        拓展性：通过从公共基类继承新数据类型而增加新功能
        代码：CPP_SIGNLE/chapter-15/Instrument4.cpp

        存放：类中有虚函数时，类的长度是本身的长度加上一个void指针的长度。即使有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针。
        这是因为单个指针指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个单个表中。

        注意点：仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual（这也是无害的),但这样会使程序段显得冗余和混乱

2021年8月2日15:07:48

//多态性和虚函数

笔记：
        1. 在基类中加入至少一个纯虚函数，来使基类成为抽象类。
        use : virtual void f()  = 0;

        2. 这样子做,等于告诉编译在VTABLE为函数保留一个位置，但在这个特定位置中不放地址，只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全中。当VTABLE不完全时 ，编译会发出错误信息

        3. 当前类中全是纯虚函数

        4. 在基类中，对纯虚函数提供定义是可能的。我们仍然告诉编译器不允许产生抽象基类的对象，而且如果要创建对象，则纯虚函数必须在派生类中定义。然后，我们可能希望一段公共代码，是一些或所有派生类定义都能调用，而不必在每个函数中重复这段代码
        代码：CPP_SIGNLE/PureVirtualDefinitions.cpp
线索：
        1. 仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类的对象。

        2. 为什么纯虚函数能阻止创建当前类

        3. 纯抽象类

        4. 纯抽象类如何不通过继承重写来使用当前的纯虚函数

2021年8月3日13:54:04

// 多态性和虚函数

笔记:
        1. 继承的最重要的方面不是它为新类提供了成员函数，而是它是基类和新类的关系，这个关系可被描述为："新类属于原有类的类型"; (编译器支持)

        2. 多态不仅可以根据不同的对象来做不同的事情，还可以让对基类对象操作的代码也能透明地操作派生类对象

        2.1 通过继承和多态可以实现代码拓展性,当出现问题时,只需要在新增的代码找原因
        //代码:CPP_SIGNLE/0803.cpp

        3. 虚机制在构造函数中不工作

        4. 不把析构函数设为虚函数是个隐匿的错误。因为它常常不会对程序有直接的英雄。但要注意它不知不觉地引入存储器泄漏（关闭程序时内存未释放）。同样，这样的析构操作还有可能掩盖发生的问题

        5. 析构函数可以是虚的，这是因为这个对象已经知道它是什么类型（而在构造期间则不然）。一旦对象已被构造，它的VPTR就已经被初始化，所以能发生虚函数调用

线索：
        1. 向上转换类型触发

        2. 多态的目的

        3. 虚函数在构造函数有没有效果

        4. 当基类有使用堆时，不把析构函数设为虚析构函数的后果

        5. 构造函数和析构函数都可以使用虚机制?




        


还没未看的文章:
    13.2.2 对指针的清楚责任（书中说后面的章节中有更加智能的方法）
    13.5 重载New和Delete之后都没看（包括这章）
    14.9 运算符的重载与继承