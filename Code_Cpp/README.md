2021年7月15日11:02:18
    构造函数初始化列表（顾名思义，只出现在构造函数的定义里）是出现在函数参数表和冒号后，
    但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造
    函数的任何代码执行之前。**这是初始化所有Const的地方！**

2021年7月22日10:05:08
    使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每
    一处重复赋值代码，这样将是代码膨胀，在速度方面获得的好处就会减少。
    (已实验过了.简单的实验调用内联函数和调用在类外实现的函数（两者实现一样）,但内联更快)

    内联函数的最重要的使用之一是用做访问函数（access funtion).

2021年7月23日14:18:40
    全局对象会在Main调用之前就会调用构造函数,静态对象是等到被调用的时候才调用构造函数。
    而在Main结束后,静态对象的析构函数会按创建时相反的顺序被调用，全局对象的析构在最后才调用。
    
2021年7月26日14:25:47
    Malloc和free是C语言的标准库函数。
    使用Malloc必须决定对象的长度。分配了一块内存而不是生了一个对象。所以它返回一个vodi * 类型指针。而C++不允许将一个void*类型指针赋予任何其他指针。所以必须做类型转换。

    C    : Obj *obj = (obj *)malloc(sizeof(Obj));
    C++  : Obj *obj = new Obj;

    而New和Delete是C++的运算符。C++的解决方案是把创建一个对象所需的所有动作都结合再一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。

    C++使在堆里创建对象的过程变得简单了——只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。

    使用 void* 类型指针进行delete操作，可能会成为一个程序错误，除非指针所值的内容是非常的简单的。因为，它将不执行析构函数(没有确切的类型)

2021年7月28日15:36:52
    构造函数的初始化表达式允许我们显式地调用成员对象的构造函数。事实上，也没有其他办法可以调用那些构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有的其他的构造函数。

    Y():X(),T(){}  //先调用X的构造函数，再调用T，最后才调用Y;

     伪构造函数语法：方便且具有良好的编码风格（作者）
        int i(100)  ==  ( int i =100 );

2021年7月29日10:34:50
     只有通过继承,才能重新定义它的函数。而对于成员对象，只能操作这个对象的公共接口,而不能重定义它.

构造函数和析构函数调用的次序:
      构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函函数。调用析构函数则严格按照构造函数相反的次序。
      另一个有趣对象是，对于成员函数，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中的声明的次序所决定的。
      代码：CPP_SIGNLE/chapter-14:Order.cpp

关于继承和组合的选择:
       组合通常是在希望新类内部具有已存在的类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。
       右存在的类创建一个新类，并且希望这个新类与已存在的类有着严格相同的接口（希望增加任何我们想要加入的其他成员函数），所以能在已经用过这个已存在类的任何地方使用这个新类。这就是可以使用继承的地方。
       代码：CPP_SIGNLE/chapter-14:FName1.cpp FName2.cpp 

私有继承注意的点：
        类默认是private继承;
        私有继承是创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能。

        Tips:
        当私有继承时，基类的所有public成员都变成private。如果希望它们的任何一个是可视的,只要用派生类的public部分声明它们的名字即可。

        代码：CPP_SIGNLE/PrivateInheritance.cpp

2021年7月29日17:15:47： 已看完第14章


还没未看的文章:
    13.2.2 对指针的清楚责任（书中说后面的章节中有更加智能的方法）
    13.5 重载New和Delete之后都没看（包括这章）
    14.9 运算符的重载与继承